<?php

if(!defined('GELF_LOG_DEFAULT_GROUP')) { define('GELF_LOG_DEFAULT_GROUP', 'no_group'); 
}
if(!defined('GELF_LOG_DEFAULT_MTU')) { define('GELF_LOG_DEFAULT_MTU', 512); 
}

function gelf_log_menu() 
{

    $items = array();

    $items['admin/config/system/gelf_log'] = array(
        'title' => 'GELF log',
        'description' =>
            t('Manage GELF log settings, including destination server and port'),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('gelf_log_admin'),
        'access arguments' => array('administer gelf_log settings'),
        'type' => MENU_NORMAL_ITEM,
    );

    return $items;
}

function gelf_log_admin() 
{
    $form = array();

    $form['gelf_log_host'] = array(
        '#type' => 'textfield',
        '#title' => t('Logging server hostname or IP'),
        '#default_value' => variable_get('gelf_log_host', '127.0.0.1'),
        '#size' => 10,
        '#maxlength' => 50,
        '#description' => t("The logging packets will be sent to this server"),
        '#required' => true,
    );

    $form['gelf_log_port'] = array(
        '#type' => 'textfield',
        '#title' => t('Logging server UDP port'),
        '#default_value' => variable_get('gelf_log_port', 12345),
        '#size' => 5,
        '#maxlength' => 5,
        '#description' => t("The logging packets will be sent on this port"),
        '#required' => true,
    );
    $form['gelf_log_mtu'] = array(
        '#type' => 'textfield',
        '#title' => t('Maximum packet size (MTU)'),
        '#default_value' => variable_get('gelf_log_mtu', GELF_LOG_DEFAULT_PACKET_SIZE),
        '#size' => 4,
        '#maxlength' => 4,
        '#description' =>
            t(
                "Maximum size of a GELF UDP datagram
            (512 is safe, 1500 is common and 8192 is the max)"
            ),
            '#required' => true,
    );
    $form['gelf_log_group'] = array(
        '#type' => 'textfield',
        '#title' => t('Group name, for IDing the website in Kibana'),
        '#default_value' => variable_get('gelf_log_group', GELF_LOG_DEFAULT_GROUP),
        '#size' => 10,
        '#maxlength' => 254,
        '#description' =>
            t(
                "Group name, for IDing/grouping the website in Kibana
            (adds an additional _group field in the gelf packet)"
            ),
            '#required' => true,
    );
    return system_settings_form($form);
}

function gelf_log_watchdog(array $error) 
{
    /* get the config from drupal */
    $host = variable_get('gelf_log_host', '127.0.0.1');
    $port = variable_get('gelf_log_port', '12345');
    $mtu = variable_get('gelf_log_mtu', GELF_LOG_DEFAULT_PACKET_SIZE);

    /* format the packet from drupal error format */
    $errorPacket = gelf_log_format_error($error);
    /* chunk and send the GELF UDP packet */
    return gelf_log_send_packet($host, $port, $errorPacket, $mtu);
}

function gelf_log_format_error(array $error) 
{

    // If drupal sets a messages and its variables , final message is message+variables
    if (isset($error['message']) && is_array($error['variables'])) {
        $message = strip_tags(format_string($error['message'], $error['variables']));
        // Else if drupal sets a messages and no variable , final message is message
    } elseif (isset($error['message'])) {
        $message = $error['type'].' '.$error['message'];
    } else {
        // If no message, all we can do is take type and hope for a clear message
        $message = $error['type'];
    }

    // Put all other fields in the gelf packet but avoid user (private, pw is there)
    foreach ($error as $error_key => $error_value) {
        unset($error[$error_key]);
        if (in_array($error_key, array('user','variables','message'))) {
            continue;
        }
        $error['_'.$error_key] = $error_value;
    }

    $error['_application'] = 'drupal_gelf_log';
    $error['_website'] =  variable_get('site_name');
    $error['_group'] = variable_get('gelf_log_group', GELF_LOG_DEFAULT_GROUP);
    return array_merge(
        array(
        /* GELF required fields : */
        'version' => '1.1',
        'host' => gethostname(),
        'short_message' => $message,
        'level' => $error['_severity'],
        'timestamp' => time()
        ),
        $error
    );
}


function gelf_log_get_unique_id($max)
{
    // generate an $max bytes unique BINARY string :
    $bytes = '';
    /* while not enough random bytes */
    while (strlen($bytes) < $max) {
        /* add one */
        $bytes .= chr(mt_rand(0, 255));
    }
    /* and return the payload */
    return $bytes;
}

function gelf_log_send_packet($host,$port,array $error_event,$mtu)
{
    //Process the packet, chunk it and sends it

    /* JSONify and compress the packet */
    $packet = gzcompress(
        json_encode($error_event)
    );
    /**
     * Split it in max $mtu bytes chunks,
     * 512 will avoid packet getting drop on low MTUs
     */
    $chunks = str_split($packet, $mtu);
    $total_chunks = count($chunks);

    /**
     * Gelf protocol specifies max 128 chunks :
     */
    if ($total_chunks > 128) {
        /**
         * We replace the error packet with "too big"
         * We also add debug details on the packet size
         */
        $error_event = gelf_log_format_error(
            array(
                'type'=>'gelf_log',
                'message'=> 'Gelf error packet is too big',
                '_gelf_chunks' => $total_chunks,
                '_gelf_mtu' => $mtu
            )
        );
        $packet = gzcompress(
            json_encode($error_event)
        );
        $chunks = str_split($packet, $mtu);
        $total_chunks = count($chunks);
    }

    $uniqid = gelf_log_get_unique_id(8);

    /* open a UDP sending socket */
    $socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);
    if ($socket === false) {
        // if the socket failed to be created, we return false ...
        return false; 
    }

    /**
     * And send packets 1 by 1, there's no support
     * for non-chunked packet, who cares ?
     */
    foreach ($chunks as $index => $chunk) {
         //create UDP packet according GELF specs :
        $udpPacket =  implode(
            '',
            array("\x1e\x0f" , $uniqid , chr($index) , chr($total_chunks) ,$chunk)
        );
        //and send it :
        socket_sendto($socket, $udpPacket, strlen($udpPacket), 0, $host, $port);
        // Note, no error to catch here, if it fails we can't do anything anyway
    }
    socket_close($socket);
}
